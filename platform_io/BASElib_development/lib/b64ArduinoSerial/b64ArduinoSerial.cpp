#include "Arduino.h"
#include "b64ArduinoSerial.h"
#include "string.h"
#include "math.h"

/// debuging functions region


void byteArrSimplePrint(uint8_t byteArr[], int len ) {
  for (int i = 0; i < len; i++) {
  Serial.print(byteArr[i], BIN);
  Serial.print("  ");
  }
}

void debugConsole(String description, String variable) {
  Serial.println(description + "::" + variable);
}

void debugLineBreak() {
  Serial.println();
  Serial.println();
}

/// end of region


/// convinent functions region


// convert the ascii_char to the corresponding b64 symbol index.
// Return:
//  0 <= result < 64 : base64 index
//  result = -1 : unidentified ascii-char. (wrong input)
int8_t asciiCharToB64Index(char ascii_char) {
  int8_t result = ascii_char;
  // Serial.println(String(result) + "asciiOriginal");
  if (64 < ascii_char && ascii_char < 91) {
    result -= 65;
  } else if (96 < ascii_char && ascii_char < 123) {
    result -= 71;
  } else if (47 < ascii_char && ascii_char < 58) {
    result += 4;
  } else if (43 == ascii_char) {
    result = 62;
  } else if (47 == ascii_char) {
    result = 63;
  } else {
    result = -1;
  }

  return result;
}



// convert the b64 symbol to the corresponding ascii_char symbol index.
// Return:
//  0 <= result < 127 : ascii char
//  result = -1 : unidentified b64. (wrong input)
char b64ByteToAsciiSymbol(uint8_t b64_char) {
  char result = b64_char;
  // Serial.println(String(result) + "asciiOriginal");
  if (0 <= b64_char && b64_char < 26) {
    result += 65;
  } else if (26 <= b64_char && b64_char < 52) {
    result += 71;
  } else if (52 <= b64_char && b64_char < 62) {
    result -= 4;
  } else if (62 == b64_char) {
    result = 43;
  } else if (63 == b64_char) {
    result = 47;
  } else {
    result = -1;
  }

  return result;
}


void flipArray(uint8_t arr[], int length) {
  uint8_t byte_storage = 0x00;
  int reverse_index = length - 1;
  int index = 0;
  while (index < reverse_index) {
    byte_storage = arr[reverse_index];
    arr[reverse_index] = arr[index];
    arr[index] = byte_storage;
    reverse_index--;
    index++;
  }
}


/// end of region


// initialize the BASE64 object with the error signs.
void BASE64::_fault_control() {
  // exception handles
  _len = -1;
  _byteArrLen = -1;
  free(_byteArr);
  _byteArr = NULL;
  _ending = -1;
  _ending_position = -1;
  _stored_length = -1;
}

// get ascii string and convert it to the base64-byte encoded object.
// assigned _byteArr will generated by stacking the bits from b64 symbol, by
// FIFO order. (first char of b64 will be placed at final index, and then pops out very first when interpret happens.)
// Param:
//   char ascii_string[] : string that contains each ascii char representing the base64 symbol.
//                         eg ) "aAbB12/+"
//   unsigned int length : string length provided. function will not check the ascii_string's length directly.
BASE64::BASE64(const char ascii_string[], unsigned int b64_length) {
  _len = b64_length;
  // assign the value to the instance fields
  _byteArrLen = (_len + 4 - (_len % 4)) * 3 / 4;

  // Serial.println(_byteArrLen);
  _byteArr = (uint8_t *)malloc(sizeof(uint8_t) * _byteArrLen);
  
  // convert the ascii symbol to the base64 symbol.
  // at the same time, save the byte representative of the b64 symbol.
  // if inappropriate ascii symbol has found, raise exception.
  uint8_t stored_bits = 0x00;
  int stored_length = 0;
  int byteArr_current_focus = _byteArrLen - 1;
  for (unsigned int i = 0; i < b64_length; i++) {
    const char target_char = ascii_string[i];
    const int8_t ascii_to_b64 = asciiCharToB64Index(target_char);
    // Serial.println(ascii_to_b64);
    if (ascii_to_b64 < 0) {
      // exception handling
      _fault_control();
      return;
    } 
    
    const uint8_t b64_index = ascii_to_b64;
    // convert b64_index to the bit form.
    // however, b64 is 6bit while byte is 8bit.
    // so, stack b64 from last index of array.

    // first, put the b64 symbol bits into the stored_bits.
    const uint8_t b64_combined = stored_bits | (b64_index << stored_length);

    stored_length += 6;
    if (stored_length < 8) {
      stored_bits = b64_combined;
    } else {
      // check if << left shift operator overflow then the digits vanish or not?
      // -> yes, vanish.
      stored_length -= 8;
      _byteArr[byteArr_current_focus] = b64_combined;
      stored_bits = b64_index >> (6 - stored_length);
      byteArr_current_focus--;
    }
  
  }

  if (stored_length > 0) {
    _byteArr[byteArr_current_focus] = stored_bits;
    _ending_position = byteArr_current_focus;
    byteArr_current_focus--;
  } else {
    _ending_position = byteArr_current_focus + 1;
  }
  _stored_length = stored_length;
  _ending = stored_bits;
  // exhaust the left byteArr_current_focus until zero, filing 0x00 for each iteration.
  while (byteArr_current_focus >= 0) {
    _byteArr[byteArr_current_focus] = 0x00;
    byteArr_current_focus--;
  }
}


 
void BASE64::extend(const char extender[], unsigned int extender_length) {
  // re-calculate the byteArrLen, and move pointer to the temporary variable
  _len += extender_length;
  int byteArrLenBefore = _byteArrLen;
  uint8_t *byteArrBefore =_byteArr;

  const int base64_byte_div = _len * 6 / 8;
  if ((_len * 6 % 8) != 0) {
    _byteArrLen = base64_byte_div + 1;
  } else {
    _byteArrLen = base64_byte_div;
  }

  // re-assign the pointer
  // Serial.println(_byteArrLen);
  _byteArr = (uint8_t *)malloc(sizeof(uint8_t) * _byteArrLen);

  // put the byteArrBefore to the _byteArr. however, the ending byte will not applied.
  int byteArr_past_focus = byteArrLenBefore - 1;
  int byteArr_current_focus = _byteArrLen - 1;
  for (int i = 0; i < byteArrLenBefore - _ending_position - 1; i++) {
    _byteArr[byteArr_current_focus] = byteArrBefore[byteArr_past_focus];
    byteArr_current_focus--;
    byteArr_past_focus--;
  }

  // debugConsole("_ending_position",String(_ending_position));
  // debugConsole("byteArr_current_focus",String(byteArr_current_focus));
  // debugConsole("byteArr_past_focus",String(byteArr_past_focus));

  // re-assign the stored_bits and its stored_length
  uint8_t stored_bits = byteArrBefore[byteArr_past_focus];
  // byteArr_current_focus--;

  // debugLineBreak() ;

  // free the array before
  free(byteArrBefore);

  int stored_length = _stored_length;
  for (unsigned int i = 0; i < extender_length; i++) {
    const char target_char = extender[i];
    const int8_t ascii_to_b64 = asciiCharToB64Index(target_char);

    if (ascii_to_b64 < 0) {
      // exception handling
      _fault_control();
      return;
    }


    // debugConsole("i",String(i));
    // debugConsole("ascii_to_b64",String(ascii_to_b64, DEC));
    const uint8_t b64_index = ascii_to_b64;
    // convert b64_index to the bit form.
    // however, b64 is 6bit while byte is 8bit.
    // so, stack b64 from last index of array.

    // first, put the b64 symbol bits into the stored_bits.
    const uint8_t b64_combined = stored_bits | (b64_index << stored_length);

    stored_length += 6;
    if (stored_length < 8) {
      stored_bits = b64_combined;
    } else {
      // check if << left shift operator overflow then the digits vanish or not?
      // -> yes, vanish.
      stored_length -= 8;
      _byteArr[byteArr_current_focus] = b64_combined;
      stored_bits = b64_index >> (6 - stored_length);
      byteArr_current_focus--;
    }
  }

  if (stored_length > 0) {
    _byteArr[byteArr_current_focus] = stored_bits;
    _ending_position = byteArr_current_focus;
    byteArr_current_focus--;
  } else {
    _ending_position = byteArr_current_focus + 1;
  }
  _stored_length = stored_length;
  _ending = stored_bits;

  // exhaust the left byteArr_current_focus until zero, filing 0x00 for each iteration.
  while (byteArr_current_focus >= 0) {
    _byteArr[byteArr_current_focus] = 0x00;
    byteArr_current_focus--;
  }
}

void BASE64::extend_float(float number) {
  union float_b64 { // warning : byte ordering is little-endian!
    uint8_t byte_arr[4];
    float number;
  } b64_float;


  b64_float.number = number;
  // //debug
  // for (int i = 0; i < 4; i++) {
  //   Serial.println(b64_float.byte_arr[i], BIN);
  // }
  // //debug

  // re-calculate the byteArrLen, and move pointer to the temporary variable
  _len += 6;
  int byteArrLenBefore = _byteArrLen;
  uint8_t *byteArrBefore =_byteArr;

  const int base64_byte_div = _len * 6 / 8;
  if ((_len * 6 % 8) != 0) {
    _byteArrLen = base64_byte_div + 1;
  } else {
    _byteArrLen = base64_byte_div;
  }

  // re-assign the pointer
  _byteArr = (uint8_t *)malloc(sizeof(uint8_t) * _byteArrLen);

  // put the byteArrBefore to the _byteArr. however, the ending byte will not applied.
  int byteArr_past_focus = byteArrLenBefore - 1;
  int byteArr_current_focus = _byteArrLen - 1;
  for (int i = 0; i < byteArrLenBefore - _ending_position - 1; i++) {
    _byteArr[byteArr_current_focus] = byteArrBefore[byteArr_past_focus];
    byteArr_current_focus--;
    byteArr_past_focus--;
  }

  // free the byteArrBefore.
  // append the float bytes.
  uint8_t stored_bits = byteArrBefore[byteArr_past_focus];
  free(byteArrBefore);

  for (unsigned int i = 0; i < 4; i++) {
    const uint8_t target_byte = b64_float.byte_arr[i];

    // first, put the b64 symbol bits into the stored_bits.
    const uint8_t b64_combined = stored_bits | (target_byte << _stored_length);

    // check if << left shift operator overflow then the digits vanish or not?
    // -> yes, vanish.
    _byteArr[byteArr_current_focus] = b64_combined;
    stored_bits = target_byte >> (8 - _stored_length);
    byteArr_current_focus--;
  }

  // we need to add the 4 zero bit to the end because of the base64 convention.
  const uint8_t target_byte = 0x00;
  const uint8_t b64_combined = stored_bits | (target_byte << _stored_length);

  _stored_length += 4;
  if (_stored_length < 8) {
    stored_bits = b64_combined;
  } else {
    // check if << left shift operator overflow then the digits vanish or not?
    // -> yes, vanish.
    _stored_length -= 8;
    _byteArr[byteArr_current_focus] = b64_combined;
    stored_bits = 0x00;
    byteArr_current_focus--;
  }


  if (_stored_length > 0) {
    _byteArr[byteArr_current_focus] = stored_bits;
    _ending_position = byteArr_current_focus;
    byteArr_current_focus--;
  } else {
    _ending_position = byteArr_current_focus + 1;
  }
  _ending = stored_bits;

  // exhaust the left byteArr_current_focus until zero, filing 0x00 for each iteration.
  while (byteArr_current_focus >= 0) {
    _byteArr[byteArr_current_focus] = 0x00;
    byteArr_current_focus--;
  }
}


// write _byteArr then deactivate this BASE64 object.
void BASE64::serial_exhaust_bytes() {
  flipArray(_byteArr, _byteArrLen);
  Serial.write((char*) _byteArr);
  _fault_control();
}

// Serial.println the _byteArr to the bit 0-1 string
void BASE64::debug_byteArr() {
  Serial.println();
  Serial.println("||DEBUG||");
  debugConsole("_len",String(_len));
  debugConsole("_byteArrLen",String(_byteArrLen));
  byteArrSimplePrint(_byteArr, _byteArrLen);
  Serial.println("||spec||");
  debugConsole("_ending",String(_ending, BIN));
  debugConsole("_ending_position",String(_ending_position));
  debugConsole("_stored_length",String(_stored_length));
  Serial.println();
}


String BASE64::b64_symbolize() {
  int len = _len;
  int byteArrLen = _byteArrLen;
  int byteArr_current_focus = byteArrLen - 1;
  String result = "";

  uint8_t stored_bits = 0x00;
  int stored_length = 0;
  const uint8_t b64_mask = 0x3F;
  for (int i = 0; i < len; i ++) {
    const uint8_t target_char = _byteArr[byteArr_current_focus];
    if (stored_length < 6) {
      const char masked = ((target_char << stored_length) | stored_bits) & b64_mask ;
      result += String(b64ByteToAsciiSymbol( masked ));
      stored_length = 2 + stored_length;
      stored_bits = target_char >> (8 - stored_length);
      byteArr_current_focus--;
    } else {
      const char masked = stored_bits & b64_mask ;
      result += String(b64ByteToAsciiSymbol(masked));
      stored_length = stored_length - 6;
      stored_bits = stored_bits >> 6;
    }
  }
  return result;
}

