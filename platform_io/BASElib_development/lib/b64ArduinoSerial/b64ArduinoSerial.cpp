#include "Arduino.h"
#include "b64ArduinoSerial.h"
#include "string.h"
#include "math.h"

// convert the ascii_char to the corresponding b64 symbol index.
// Return:
//  0 <= result < 64 : base64 index
//  result = -1 : unidentified ascii-char. (wrong input)
int8_t asciiCharToB64Index(char ascii_char) {
  int8_t result = ascii_char;
  Serial.println(String(result) + "asciiOriginal");
  if (64 < ascii_char && ascii_char < 91) {
    result -= 65;
  } else if (96 < ascii_char && ascii_char < 123) {
    result -= 71;
  } else if (47 < ascii_char && ascii_char < 58) {
    result += 4;
  } else if (43 == ascii_char) {
    result = 62;
  } else if (47 == ascii_char) {
    result = 63;
  } else {
    result = -1;
  }

  return result;
}

// get ascii string and convert it to the base64-byte encoded object.
// assigned _byteArr will generated by stacking the bits from b64 symbol, by
// FILO order. (first char of b64 will be placed at last index.)
// Param:
//   char ascii_string[] : string that contains each ascii char representing the base64 symbol.
//                         eg ) "aAbB12/+"
//   unsigned int length : string length provided. function will not check the ascii_string's length directly.
BASE64::BASE64(char ascii_string[], unsigned int b64_length) {
  _len = b64_length;
  // assign the value to the instance fields
  const int base64_byte_div = b64_length * 6 / 8;
  if ((b64_length * 6 % 8) != 0) {
    _byteArrLen = base64_byte_div + 1;
  } else {
    _byteArrLen = base64_byte_div;
  }

  Serial.println(_byteArrLen);
  _byteArr = (uint8_t *)malloc(sizeof(uint8_t) * _byteArrLen);
  
  // convert the ascii symbol to the base64 symbol.
  // at the same time, save the byte representative of the b64 symbol.
  // if inappropriate ascii symbol has found, raise exception.
  uint8_t stored_bits = 0x00;
  int stored_length = 0;
  int byteArr_current_focus = _byteArrLen - 1;
  for (unsigned int i = 0; i < b64_length; i++) {
    const char target_char = ascii_string[i];
    const int8_t ascii_to_b64 = asciiCharToB64Index(target_char);
    if (ascii_to_b64 < 0) {
      // exception handling
    } else {
      const uint8_t b64_index = ascii_to_b64;
      Serial.println(b64_index);
      // convert b64_index to the bit form.
      // however, b64 is 6bit while byte is 8bit.
      // so, stack b64 from last index of array.

      // first, put the b64 symbol bits into the stored_bits.
      const uint8_t b64_combined = stored_bits | (b64_index << stored_length);
      // Serial.println(stored_bits, BIN);
      // Serial.println(stored_length);
      // Serial.println( (b64_index << stored_length), BIN);
      Serial.println( b64_combined, BIN);
      stored_length += 6;
      if (stored_length < 8) {
        stored_bits = b64_combined;
      } else {
        // check if << left shift operator overflow then the digits vanish or not?
        // -> yes, vanish.
        stored_length -= 8;
        _byteArr[byteArr_current_focus] = b64_combined;
        byteArr_current_focus--;
        stored_bits = b64_index >> (6 - stored_length);
      }

    }
  }
  // exhaust the left byteArr_current_focus until zero, filing 0x00 for each iteration.
  while (byteArr_current_focus >= 0) {
    _byteArr[byteArr_current_focus] = 0x00;
    byteArr_current_focus--;
  }
}



// Serial.println the _byteArr to the bit 0-1 string
void BASE64::debug_byteArr() {
  Serial.println();
  for (int i = 0; i < _byteArrLen; i++) {
    Serial.print(_byteArr[i], BIN);
    Serial.print("  ");
  }
}